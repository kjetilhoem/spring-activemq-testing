<?xml version="1.0" encoding="UTF-8"?>
<beans default-autowire="no" xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p"
    xmlns:int-jms="http://www.springframework.org/schema/integration/jms"
    xmlns:int="http://www.springframework.org/schema/integration"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/integration/jms
    http://www.springframework.org/schema/integration/jms/spring-integration-jms-2.0.xsd
    http://www.springframework.org/schema/integration
    http://www.springframework.org/schema/integration/spring-integration-2.0.xsd">
    
    
    <!-- 
        Case #1, synchronous remote procedure call using JMS & tmp-queues for responses. This type of pattern
        is only applicable when the response isn't critical, i.e. when querying for data. If the producer goes
        down, the response-message will be lost.
        In this case, transactions don't make sense at all on the client-side.
     -->
     
        <!-- Proxy for the EmailValidator interface, delivers messages to the 'emailValidationRequestChannel' -->
    <int:gateway id="emailAddressValidator"
        service-interface="testing.common.EmailValidator"
        default-request-channel="emailValidationRequestChannel" />
        
        <!-- internal representation of the target JMS-queue -->
    <int:channel id="emailValidationRequestChannel" />
    
        <!--
            handles messages on the internal channel, converts them to JMS-messages, delivered to the
            'Infrastructure.EmailValidation' queue. Responses are delivered to a tmp-queue & piped back
            to the gateway.
         -->
    <int-jms:outbound-gateway request-channel="emailValidationRequestChannel"
        request-destination-name="Infrastructure.EmailValidation"
        message-converter="coreApiMarshallingMessageConverter"
        receive-timeout="1000" /> <!-- the timeout-handling can be triggered by invoking 'validateEmailAddress timeout' -->
        
        
    <!-- 
        Case #2, dispatch an important request, and handle it's response asynchronously. In this scenario both
        the request/reply could use transactions.
     -->
    <int-jms:outbound-channel-adapter destination-name="Orders.New"
        channel="newOrderRequestChannel" />
        
    <int:channel id="newOrderRequestChannel" />
    
    <!-- TODO transactions please, acknowledge="transacted"? + transaction-manager= -->
    <int-jms:message-driven-channel-adapter channel="newOrderResponseChannel"
        container="createdOrderListenerContainer" />

        <!--
            the message-drive-channel-adapter element doesn't have support for durable subscriptions,
            the following bean is basically the regular spring-jms backend-class for message-driven beans,
            we could probably wrap most of the boilerplate here in an abstract bean     
         -->        
    <bean id="createdOrderListenerContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"
            p:destinationName="Orders.Created"
            p:subscriptionDurable="true"
            p:durableSubscriptionName="CreatedOrders"
            p:pubSubDomain="true" 
            p:clientId="#{systemProperties['JmsClientId']}">
        <property name="connectionFactory" ref="connectionFactory"/>
        <!-- TODO transaction-manager here? -->
        
    </bean>
    
    <int:channel id="newOrderResponseChannel" />
        
    <int:service-activator input-channel="newOrderResponseChannel"
        ref="orderStatusListenerEndpoint" />
         
</beans>
